#!/usr/bin/env node
/**
 * Automatically extract and bundle only used icons
 * Usage: node tools/extract-used-icons.js
 */

import { readFileSync, writeFileSync, readdirSync, statSync } from 'fs'
import { join, extname } from 'path'
import { fileURLToPath, pathToFileURL } from 'url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = join(__filename, '..')

async function scanForUsedIcons(srcDir) {
  const usedIcons = new Set()
  
  function scanFile(filePath) {
    try {
      const content = readFileSync(filePath, 'utf-8')
      const iconMatches = content.match(/Symbol\s*\(\s*['"`]([^'"`]+)['"`]/g)
      
      if (iconMatches) {
        iconMatches.forEach(match => {
          const iconName = match.match(/['"`]([^'"`]+)['"`]/)[1]
          usedIcons.add(iconName)
        })
      }
    } catch (error) {
      console.warn(`Could not scan ${filePath}:`, error.message)
    }
  }
  
  function scanDirectory(dir) {
    const files = readdirSync(dir)
    
    for (const file of files) {
      const filePath = join(dir, file)
      const stat = statSync(filePath)
      
      if (stat.isDirectory() && !file.startsWith('.') && file !== 'node_modules') {
        scanDirectory(filePath)
      } else if (['.ts', '.tsx', '.js', '.jsx'].includes(extname(file))) {
        scanFile(filePath)
      }
    }
  }
  
  scanDirectory(srcDir)
  return Array.from(usedIcons).sort()
}

async function extractIconSVG(iconName) {
  try {
    // Dynamic import to get the specific icon
    const lucide = await import('lucide')
    const pascalName = iconName.split('-').map(part => 
      part.charAt(0).toUpperCase() + part.slice(1)
    ).join('')
    
    const iconData = lucide[pascalName]
    if (!iconData || !Array.isArray(iconData) || iconData.length < 3) {
      throw new Error(`Icon ${iconName} (${pascalName}) not found`)
    }
    
    const [, , children] = iconData
    if (!Array.isArray(children)) {
      throw new Error(`Invalid icon data for ${iconName}`)
    }
    
    const svg = children.map(child => {
      if (!Array.isArray(child) || child.length < 2) return ''
      
      const [tagName, attributes] = child
      const attrs = Object.entries(attributes || {})
        .map(([key, value]) => `${key}="${value}"`)
        .join(' ')
      
      return `<${tagName} ${attrs}/>`
    }).join('')
    
    return svg
  } catch (error) {
    console.error(`Failed to extract ${iconName}:`, error.message)
    return null
  }
}

async function generateIconSet(usedIcons, outputPath) {
  const iconEntries = []
  
  for (const iconName of usedIcons) {
    const svg = await extractIconSVG(iconName)
    if (svg) {
      iconEntries.push(`  '${iconName}': '${svg}'`)
    }
  }
  
  const template = `/**
 * Auto-generated icon set - DO NOT EDIT MANUALLY
 * Generated at: ${new Date().toISOString()}
 * Icons: ${usedIcons.join(', ')}
 */
import { IconSetRegistry } from '@tachui/symbols'
import type { IconSet, IconDefinition, SymbolVariant } from '@tachui/symbols'

const iconData: Record<string, string> = {
${iconEntries.join(',\n')}
}

class AutoGeneratedIconSet implements IconSet {
  name = 'auto-generated'
  version = '1.0.0'
  icons = iconData

  async getIcon(name: string, variant: SymbolVariant = 'none'): Promise<IconDefinition | undefined> {
    const svg = iconData[name]
    if (!svg) {
      console.warn(\`Icon "\${name}" not found in auto-generated icon set\`)
      return undefined
    }

    return {
      name,
      variant,
      weight: 'regular',
      svg,
      viewBox: '0 0 24 24'
    }
  }

  hasIcon(name: string): boolean {
    return name in iconData
  }

  listIcons(): string[] {
    return Object.keys(iconData)
  }

  getIconMetadata(): undefined {
    return undefined
  }

  supportsVariant(_name: string, variant: SymbolVariant): boolean {
    return variant === 'none'
  }

  supportsWeight(_name: string, _weight: any): boolean {
    return true
  }
}

// Auto-register the generated icon set
const iconSet = new AutoGeneratedIconSet()
IconSetRegistry.register(iconSet)
IconSetRegistry.setDefault('auto-generated')

export { AutoGeneratedIconSet }
`

  writeFileSync(outputPath, template, 'utf-8')
  console.log(`‚úÖ Generated icon set with ${usedIcons.length} icons: ${outputPath}`)
}

async function main() {
  const srcDir = process.argv[2] || 'src'
  const outputPath = process.argv[3] || 'src/icons/auto-generated.ts'
  
  console.log(`üîç Scanning ${srcDir} for used icons...`)
  const usedIcons = await scanForUsedIcons(srcDir)
  
  if (usedIcons.length === 0) {
    console.log('‚ùå No icons found in source code')
    return
  }
  
  console.log(`üì¶ Found ${usedIcons.length} used icons:`, usedIcons.join(', '))
  
  await generateIconSet(usedIcons, outputPath)
}

if (import.meta.url === pathToFileURL(process.argv[1]).href) {
  main().catch(console.error)
}