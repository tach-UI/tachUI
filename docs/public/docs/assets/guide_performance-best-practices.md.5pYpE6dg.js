import{_ as r,c as a,o as i,ag as t}from"./chunks/framework.DH_Cy_iG.js";const p=JSON.parse('{"title":"Performance Best Practices","description":"","frontmatter":{},"headers":[],"relativePath":"guide/performance-best-practices.md","filePath":"guide/performance-best-practices.md"}'),o={name:"guide/performance-best-practices.md"};function s(n,e,l,c,d,h){return i(),a("div",null,[...e[0]||(e[0]=[t('<h1 id="performance-best-practices" tabindex="-1">Performance Best Practices <a class="header-anchor" href="#performance-best-practices" aria-label="Permalink to &quot;Performance Best Practices&quot;">​</a></h1><p>TachUI is designed to stay responsive even as modifier chains grow. These practices keep applications fast in both development and production.</p><h2 id="lean-imports-tree-shaking" tabindex="-1">Lean Imports &amp; Tree Shaking <a class="header-anchor" href="#lean-imports-tree-shaking" aria-label="Permalink to &quot;Lean Imports &amp; Tree Shaking&quot;">​</a></h2><ul><li><strong>Prefer <code>@tachui/modifiers</code> for concrete modifiers.</strong> It auto-registers metadata and keeps runtime bundles small. Import only what you use.</li><li><strong>Avoid re-exporting modifiers from app-level barrels</strong> unless your bundler aggressively treeshakes; otherwise the entire modifier catalog might ship to clients.</li><li><strong>Code-split heavy packages</strong> (navigation, data, responsive) with dynamic imports so rarely used flows do not impact initial load.</li></ul><h2 id="keep-modifier-metadata-fresh" tabindex="-1">Keep Modifier Metadata Fresh <a class="header-anchor" href="#keep-modifier-metadata-fresh" aria-label="Permalink to &quot;Keep Modifier Metadata Fresh&quot;">​</a></h2><ul><li>Run <code>pnpm --filter @tachui/core generate-modifier-types -- --check</code> in CI to catch stale declarations before publishing.</li><li>After creating or renaming modifiers, regenerate types and commit both the declaration (<code>generated-modifiers.d.ts</code>) and snapshot JSON so consumers stay in sync.</li><li>Enforce the ESLint rule <code>@tachui/prefer-direct-modifiers</code> to guarantee code paths use the proxy layer that benefits from metadata caching.</li></ul><h2 id="work-with-the-component-proxy" tabindex="-1">Work With the Component Proxy <a class="header-anchor" href="#work-with-the-component-proxy" aria-label="Permalink to &quot;Work With the Component Proxy&quot;">​</a></h2><ul><li><strong>Reuse base components via <code>clone()</code></strong> instead of rebuilding modifier chains; cloning preserves cached modifier functions and keeps GC churn low.</li><li>Apply additional modifiers directly on clones. Mutating the original component after a clone can invalidate caches and cause extra diffing work.</li><li>For HMR scenarios, call <code>registerCoreModifiers({ force: true })</code> after editing modifier modules so stale factories are purged without restarting the dev server.</li></ul><h2 id="measure-early-often" tabindex="-1">Measure Early &amp; Often <a class="header-anchor" href="#measure-early-often" aria-label="Permalink to &quot;Measure Early &amp; Often&quot;">​</a></h2><ul><li>Use <code>pnpm benchmark:quick</code> while tuning modifiers; it exercises the registry in a controlled JSDOM environment.</li><li>Run <code>pnpm benchmark:browser:quick</code> for real browser timings before merging large styling changes.</li><li>Treat the calculator and intro demos as smoke tests—build them (<code>pnpm --filter @tachui/calculator-app build</code>, <code>pnpm --filter @tachui/intro-app build</code>) to verify bundle size stays within expectations.</li></ul><h2 id="reduce-re-render-pressure" tabindex="-1">Reduce Re-render Pressure <a class="header-anchor" href="#reduce-re-render-pressure" aria-label="Permalink to &quot;Reduce Re-render Pressure&quot;">​</a></h2><ul><li>Prefer derived signals (<code>createComputed</code>) to prepare formatted strings or layout data rather than rebuilding modifier chains inside effects.</li><li>Pre-clone frequently reused view templates and reuse the clones inside animation frames or timers.</li><li>Stream large lists into <code>ForEach</code> within <code>ScrollView</code>; the built-in recycling avoids destroying modifiers between scroll frames.</li></ul><h2 id="tooling-hooks-worth-enabling" tabindex="-1">Tooling Hooks Worth Enabling <a class="header-anchor" href="#tooling-hooks-worth-enabling" aria-label="Permalink to &quot;Tooling Hooks Worth Enabling&quot;">​</a></h2><ul><li>Keep <code>SECURITY_DEV_MODE</code> enabled in development—it logs warnings for unsafe HTML modifiers that often trigger costly reflows.</li><li>Run targeted performance tests such as <code>packages/core/__tests__/performance/memory-usage-tracking.test.ts</code> before publishing modifier-heavy releases.</li><li>Install <code>@tachui/devtools</code> during development to inspect modifier hydration costs and confirm registry metadata is loading as expected.</li></ul><p>Following these guidelines keeps the proxy-based modifier system fast and predictable as teams add new modifiers and plugins.</p>',15)])])}const u=r(o,[["render",s]]);export{p as __pageData,u as default};
